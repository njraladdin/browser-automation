<!DOCTYPE html>
<html>
<head>
  <title>Web Automation Builder</title>
  <link href="/css/styles.css" rel="stylesheet">
</head>
<body>
  <div id="flowModal" class="modal">
    <div class="modal-content">
      <h2>Create New Flow</h2>
      <div class="form-group">
        <label for="flowName">Flow Name:</label>
        <input type="text" id="flowName" placeholder="Enter flow name..." />
      </div>
      <div class="form-group">
        <label for="flowDescription">Description (optional):</label>
        <textarea id="flowDescription" placeholder="Enter flow description..."></textarea>
      </div>
      <div class="modal-buttons">
        <button onclick="createFlow()" class="btn btn-primary">Create</button>
        <button onclick="closeFlowModal()" class="btn">Cancel</button>
      </div>
    </div>
  </div>

  <div class="header">
    <div class="header-left">
      <h1>Web Automation Builder</h1>
      <div class="flow-selector">
        <select id="flowSelect" onchange="selectFlow(this.value)">
          <option value="">Select a flow...</option>
        </select>
        <button onclick="showFlowModal()" class="btn btn-primary">New Flow</button>
      </div>
    </div>
    <div class="header-right">
      <button onclick="executeSteps()" class="btn btn-play" id="playButton" disabled title="Run automation from where it left off">
        <span class="btn-text">▶ Play All Steps</span>
      </button>
      <button onclick="resetExecution()" class="btn" disabled>Reset Progress</button>
    </div>
  </div>

  <div id="stepsList"></div>

  <div id="status" class="status"></div>

  <script>
    let steps = [];
    let lastExecutedStep = -1;
    let currentFlowId = null;

    // Initialize with first empty step
    window.onload = () => {
      if (steps.length === 0) {
        updateStepsList();
      }
    };

    async function addStep(stepNumber) {
      if (!currentFlowId) {
        showStatus('Please select or create a flow first', 'error');
        return;
      }
      
      const input = document.querySelector(`#step-input-${stepNumber}`);
      if (!input || !input.value) return;

      const instructions = input.value;
      const stepBlock = document.querySelector(`#step-${stepNumber}`);
      const addButton = stepBlock.querySelector('.btn-primary');
      const playButton = document.getElementById('playButton');
      
      // Disable the input and button, show loading state
      input.disabled = true;
      addButton.disabled = true;
      stepBlock.classList.add('loading');
      
      try {
        const response = await fetch(`/flows/${currentFlowId}/step`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ instructions })
        });
        
        const data = await response.json();
        if (data.success) {
          steps.push({ 
            instructions, 
            code: data.code
          });
          
          updateStepsList();
          showStatus('Step added successfully!');
          stepBlock.classList.remove('loading');
          playButton.disabled = false;
        } else {
          showStatus(`Error: ${data.error}`);
          input.disabled = false;
          addButton.disabled = false;
          stepBlock.classList.remove('loading');
        }
      } catch (error) {
        showStatus(`Error: ${error.message}`);
        input.disabled = false;
        addButton.disabled = false;
        stepBlock.classList.remove('loading');
      }
    }

    function updateStepsList() {
      const stepsList = document.getElementById('stepsList');
      const playButton = document.getElementById('playButton');
      
      // If no flow is selected, show message instead of steps
      if (!currentFlowId) {
        stepsList.innerHTML = `
          <div class="no-flow-message">
            <p>👆 Please select or create a flow to start adding automation steps</p>
          </div>
        `;
        return;
      }
      
      playButton.disabled = steps.length === 0;
      
      const buttonText = lastExecutedStep >= 0 ? '▶ Continue All Steps' : '▶ Play All Steps';
      playButton.querySelector('.btn-text').textContent = buttonText;
      
      const stepsHtml = steps.map((step, index) => `
        <div class="step-block ${index <= lastExecutedStep ? 'executed' : ''}" id="step-${index + 1}">
          <div class="step-content">
            <div class="step-main-content">
              <div class="step-number">${index + 1}</div>
              <div class="step-input-container">
                <input type="text" value="${step.instructions}" class="step-input" readonly />
                ${step.code ? `
                  <div class="code-block">
                    <div class="code-block-header" onclick="toggleCodeBlock(this)">
                      <span>🤖 Automation Code</span>
                      <span class="toggle-icon"></span>
                    </div>
                    <pre>${step.code}</pre>
                  </div>
                ` : ''}
                ${step.extractedData ? `
                  <div class="data-block">
                    <div class="data-block-header" onclick="toggleDataBlock(this)">
                      <span>📊 Extracted Data</span>
                      <span class="toggle-icon"></span>
                    </div>
                    <pre>${typeof step.extractedData === 'string' 
                      ? step.extractedData 
                      : JSON.stringify(step.extractedData, null, 2)}</pre>
                  </div>
                ` : ''}
              </div>
            </div>
            <div class="step-interactive">
              <button onclick="executeStep(${index})" class="btn btn-play" id="play-step-${index}">
                ▶ Play Step
              </button>
              <div class="step-thumbnail">
                ${step.screenshot ? `
                  <img src="${step.screenshot}" alt="Step ${index + 1} result" />
                ` : 'Result Screenshot'}
              </div>
            </div>
          </div>
        </div>
      `).join('');

      const newStepNumber = steps.length + 1;
      const newStepHtml = `
        <div class="step-block" id="step-${newStepNumber}">
          <div class="step-content">
            <div class="step-main-content">
              <div class="step-number">${newStepNumber}</div>
              <div class="step-input-container">
                <input type="text" 
                  id="step-input-${newStepNumber}" 
                  placeholder="Go to website, click button, type text..."
                  class="step-input"
                  onkeypress="if(event.key === 'Enter') addStep(${newStepNumber})" />
                ${newStepNumber === 1 ? `
                  <div class="help-text">
                    <p>💡 Examples of what you can type:</p>
                    <ul>
                      <li>"Go to wikipedia.org"</li>
                      <li>"Type 'Hello' in the message field"</li>
                      <li>"Click the Subscribe button"</li>
                    </ul>
                  </div>
                ` : ''}
              </div>
            </div>
            <div class="step-interactive">
              <button onclick="addStep(${newStepNumber})" class="btn btn-primary">
                Add Step
              </button>
            </div>
          </div>
        </div>
      `;

      stepsList.innerHTML = stepsHtml + newStepHtml;
    }

    async function executeSteps() {
      if (!currentFlowId) {
        showStatus('Please select a flow first', 'error');
        return;
      }
      console.log('[Frontend] Executing steps for flow:', currentFlowId);
  console.log('[Frontend] Current steps:', steps);

      const playButton = document.getElementById('playButton');
      playButton.disabled = true;
      playButton.querySelector('.btn-text').textContent = '⏳ Running...';
      
      // Find the first unexecuted step
      const nextStepIndex = lastExecutedStep + 1;
      const nextStep = document.querySelector(`#step-${nextStepIndex + 1}`);
      if (nextStep) {
        nextStep.classList.add('executing');
      }
      
      try {
        const response = await fetch(`/flows/${currentFlowId}/execute`, {
          method: 'POST'
        });
        
        const data = await response.json();
        if (data.success) {
          console.log('Received steps from server:', data.steps);
          lastExecutedStep = data.lastExecutedStep;
          steps = data.steps;
          updateStepsList();
          showStatus('Steps executed successfully!');
          
          playButton.disabled = lastExecutedStep >= steps.length - 1;
        } else {
          showStatus(`Error: ${data.error}`, 'error');
          playButton.disabled = false;
        }
      } catch (error) {
        showStatus(`Error: ${error.message}`, 'error');
        playButton.disabled = false;
      } finally {
        // Update button text based on execution state when done
        const buttonText = lastExecutedStep >= 0 ? '▶ Continue All Steps' : '▶ Play All Steps';
        playButton.querySelector('.btn-text').textContent = buttonText;
        
        // Remove executing class
        const executingStep = document.querySelector('.executing');
        if (executingStep) {
          executingStep.classList.remove('executing');
        }
      }
    }

    async function executeAllSteps() {
      await resetExecution();
      await executeSteps();
    }

    async function resetExecution() {
      if (!currentFlowId) {
        showStatus('Please select a flow first', 'error');
        return;
      }

      const status = document.getElementById('status');
      const playButton = document.getElementById('playButton');
      
      try {
        await fetch(`/flows/${currentFlowId}/reset`, { method: 'POST' });
        lastExecutedStep = -1;
        updateStepsList();
        status.textContent = 'Execution reset to beginning';
        playButton.disabled = false;
      } catch (error) {
        status.textContent = `Error: ${error.message}`;
      }
    }

    async function closeBrowser() {
      const status = document.getElementById('status');
      
      try {
        await fetch('/close', { method: 'POST' });
        status.textContent = 'Browser closed';
      } catch (error) {
        status.textContent = `Error: ${error.message}`;
      }
    }

    function showStatus(message, type = 'success') {
      const status = document.getElementById('status');
      if (!status) return;
      
      status.textContent = message;
      status.className = `status visible ${type}`;
      
      setTimeout(() => {
        status.className = 'status';
      }, 3000);
    }

    function toggleDataBlock(header) {
      const dataBlock = header.parentElement;
      dataBlock.classList.toggle('collapsed');
    }

    async function loadFlows() {
      try {
        const response = await fetch('/flows');
        const flows = await response.json();
        const select = document.getElementById('flowSelect');
        
        select.innerHTML = '<option value="">Select a flow...</option>' + 
          flows.map(flow => `
            <option value="${flow.id}">${flow.name}</option>
          `).join('');
      } catch (error) {
        showStatus('Failed to load flows', 'error');
      }
    }

    function showFlowModal() {
      document.getElementById('flowModal').style.display = 'block';
    }

    function closeFlowModal() {
      document.getElementById('flowModal').style.display = 'none';
    }

    async function createFlow() {
      const name = document.getElementById('flowName').value;
      const description = document.getElementById('flowDescription').value;
      
      if (!name) {
        showStatus('Flow name is required', 'error');
        return;
      }
      
      try {
        const response = await fetch('/flows', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, description })
        });
        
        const flow = await response.json();
        await loadFlows();
        closeFlowModal();
        
        // Set the select value to the new flow
        const flowSelect = document.getElementById('flowSelect');
        flowSelect.value = flow.id;
        
        // Clear the form for next time
        document.getElementById('flowName').value = '';
        document.getElementById('flowDescription').value = '';
        
        // Select the new flow
        selectFlow(flow.id);
      } catch (error) {
        showStatus('Failed to create flow', 'error');
      }
    }

    async function selectFlow(flowId) {
      if (!flowId) {
        // Clear current flow when selecting empty option
        currentFlowId = null;
        steps = [];
        lastExecutedStep = -1;
        disableAutomationButtons();
        updateStepsList();
        return;
      }
      
      try {
        const response = await fetch(`/flows/${flowId}/steps`);
        const flowSteps = await response.json();
        
        steps = flowSteps.map(step => ({
          instructions: step.instructions,
          code: step.code
        }));
        
        currentFlowId = flowId;
        lastExecutedStep = -1; // Reset execution state for new flow
        enableAutomationButtons();
        updateStepsList();
      } catch (error) {
        showStatus('Failed to load flow steps', 'error');
      }
    }

    function disableAutomationButtons() {
      document.getElementById('playButton').disabled = true;
      document.querySelectorAll('.header-right .btn').forEach(btn => btn.disabled = true);
    }

    function enableAutomationButtons() {
      document.getElementById('playButton').disabled = false;
      document.querySelectorAll('.header-right .btn').forEach(btn => btn.disabled = false);
    }

    // Add this to window.onload to load flows on page load
    window.onload = () => {
      loadFlows();
      updateStepsList(); // This will now show the "select a flow" message
    };

    async function executeStep(stepIndex) {
      if (!currentFlowId) {
        showStatus('Please select a flow first', 'error');
        return;
      }
      
      const stepBlock = document.querySelector(`#step-${stepIndex + 1}`);
      const playButton = document.querySelector(`#play-step-${stepIndex}`);
      stepBlock.classList.add('executing');
      playButton.disabled = true;
      
      try {
        const response = await fetch(`/flows/${currentFlowId}/execute-step/${stepIndex}`, {
          method: 'POST'
        });
        
        const data = await response.json();
        if (data.success) {
          lastExecutedStep = stepIndex;
          steps = data.steps;
          updateStepsList();
          showStatus('Step executed successfully!');
        } else {
          showStatus(`Error: ${data.error}`, 'error');
        }
      } catch (error) {
        showStatus(`Error: ${error.message}`, 'error');
      } finally {
        stepBlock.classList.remove('executing');
        playButton.disabled = false;
      }
    }

    function toggleCodeBlock(header) {
      const codeBlock = header.parentElement;
      codeBlock.classList.toggle('collapsed');
    }
  </script>


</body>
</html> 